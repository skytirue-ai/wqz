import{$ as e,A as t,C as n,E as r,F as i,I as a,L as o,O as s,P as c,Q as l,S as u,T as d,at as f,ct as p,et as m,j as h,k as g,lt as _,n as v,nt as y,ot as b,rt as x,tt as S,ut as C,w}from"./index-CG3uUGt1.js";function T(e){let{abi:n,data:r}=e,i=a(r,0,4),o=n.find(e=>e.type===`function`&&i===g(_(e)));if(!o)throw new x(i,{docsPath:`/docs/contract/decodeFunctionData`});return{functionName:o.name,args:`inputs`in o&&o.inputs&&o.inputs.length>0?t(o.inputs,a(r,4)):void 0}}var E=`/docs/contract/encodeErrorResult`;function D(t){let{abi:n,errorName:r,args:a}=t,o=n[0];if(r){let e=s({abi:n,args:a,name:r});if(!e)throw new m(r,{docsPath:E});o=e}if(o.type!==`error`)throw new m(void 0,{docsPath:E});let c=_(o),l=g(c),u=`0x`;if(a&&a.length>0){if(!o.inputs)throw new e(o.name,{docsPath:E});u=h(o.inputs,a)}return i([l,u])}var O=`/docs/contract/encodeFunctionResult`;function k(e){let{abi:t,functionName:n,result:r}=e,i=t[0];if(n){let e=s({abi:t,name:n});if(!e)throw new S(n,{docsPath:O});i=e}if(i.type!==`function`)throw new S(void 0,{docsPath:O});if(!i.outputs)throw new y(i.name,{docsPath:O});let a=(()=>{if(i.outputs.length===0)return[];if(i.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new f(r)})();return h(i.outputs,a)}async function A(e){let{data:t,ccipRequest:n}=e,{args:[r]}=T({abi:C,data:t}),i=[],a=[];return await Promise.all(r.map(async(e,t)=>{try{a[t]=e.urls.includes(`x-batch-gateway:true`)?await A({data:e.data,ccipRequest:n}):await n(e),i[t]=!1}catch(e){i[t]=!0,a[t]=j(e)}})),k({abi:C,functionName:`query`,result:[i,a]})}function j(e){return e.name===`HttpRequestError`&&e.status?D({abi:C,errorName:`HttpError`,args:[e.status,e.shortMessage]}):D({abi:[r],errorName:`Error`,args:[`shortMessage`in e?e.shortMessage:e.message]})}function M(e,t){if(!o(e,{strict:!1}))throw new l({address:e});if(!o(t,{strict:!1}))throw new l({address:t});return e.toLowerCase()===t.toLowerCase()}var N=class extends b{constructor({callbackSelector:e,cause:t,data:r,extraData:i,sender:a,urls:o}){super(t.shortMessage||`An error occurred while fetching for an offchain result.`,{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?``:[],`Offchain Gateway Call:`,o&&[`  Gateway URL(s):`,...o.map(e=>`    ${n(e)}`)],`  Sender: ${a}`,`  Data: ${r}`,`  Callback selector: ${e}`,`  Extra data: ${i}`].flat(),name:`OffchainLookupError`})}},P=class extends b{constructor({result:e,url:t}){super(`Offchain gateway response is malformed. Response data must be a hex value.`,{metaMessages:[`Gateway URL: ${n(t)}`,`Response: ${w(e)}`],name:`OffchainLookupResponseMalformedError`})}},F=class extends b{constructor({sender:e,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${e}`],name:`OffchainLookupSenderMismatchError`})}};const I=`0x556f1830`,L={name:`OffchainLookup`,type:`error`,inputs:[{name:`sender`,type:`address`},{name:`urls`,type:`string[]`},{name:`callData`,type:`bytes`},{name:`callbackFunction`,type:`bytes4`},{name:`extraData`,type:`bytes`}]};async function R(e,{blockNumber:t,blockTag:n,data:r,to:i}){let{args:a}=d({data:r,abi:[L]}),[o,s,l,u,f]=a,{ccipRead:p}=e,m=p&&typeof p?.request==`function`?p.request:z;try{if(!M(i,o))throw new F({sender:o,to:i});let r=s.includes(`x-batch-gateway:true`)?await A({data:l,ccipRequest:m}):await m({data:l,sender:o,urls:s}),{data:a}=await v(e,{blockNumber:t,blockTag:n,data:c([u,h([{type:`bytes`},{type:`bytes`}],[r,f])]),to:i});return a}catch(e){throw new N({callbackSelector:u,cause:e,data:r,extraData:f,sender:o,urls:s})}}async function z({data:e,sender:t,urls:n}){let r=Error(`An unknown error occurred.`);for(let i=0;i<n.length;i++){let a=n[i],o=a.includes(`{data}`)?`GET`:`POST`,s=o===`POST`?{data:e,sender:t}:void 0,c=o===`POST`?{"Content-Type":`application/json`}:{};try{let n=await fetch(a.replace(`{sender}`,t.toLowerCase()).replace(`{data}`,e),{body:JSON.stringify(s),headers:c,method:o}),i;if(i=n.headers.get(`Content-Type`)?.startsWith(`application/json`)?(await n.json()).data:await n.text(),!n.ok){r=new u({body:s,details:i?.error?w(i.error):n.statusText,headers:n.headers,status:n.status,url:a});continue}if(!p(i)){r=new P({result:i,url:a});continue}return i}catch(e){r=new u({body:s,details:e.message,url:a})}}throw r}export{z as ccipRequest,R as offchainLookup,L as offchainLookupAbiItem,I as offchainLookupSignature};