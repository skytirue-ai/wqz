import{_ as ct,a as bt,c as vt,d as Ot,f as _t,g as Ct,h as ft,i as lt,l as ee,m as At,n as at,o as et,p as Mt,r as ne,s as Vt,t as it,u as K,v as ut}from"./utils-DgRhDAqe.js";import{t as re}from"./sha2-B63zv1CH.js";import{G as oe,J as ie,K as Lt,W as se,X as ae,Z as ce,et as fe,nt as le,q as ue}from"./index-D2fX_Gsj.js";var Yt=class extends se{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ue(e);const t=le(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(t.length>o?e.create().update(t).digest():t);for(let a=0;a<i.length;a++)i[a]^=54;this.iHash.update(i),this.oHash=e.create();for(let a=0;a<i.length;a++)i[a]^=106;this.oHash.update(i),ae(i)}update(e){return Lt(this),this.iHash.update(e),this}digestInto(e){Lt(this),oe(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:t,finished:o,destroyed:i,blockLen:a,outputLen:f}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=a,e.outputLen=f,e.oHash=n._cloneInto(e.oHash),e.iHash=t._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const jt=(e,n,t)=>new Yt(e,n).update(t).digest();jt.create=(e,n)=>new Yt(e,n);var V=BigInt(0),_=BigInt(1),tt=BigInt(2),de=BigInt(3),Ut=BigInt(4),Kt=BigInt(5),Pt=BigInt(8);function Y(e,n){const t=e%n;return t>=V?t:n+t}function U(e,n,t){let o=e;for(;n-- >V;)o*=o,o%=t;return o}function Bt(e,n){if(e===V)throw new Error("invert: expected non-zero number");if(n<=V)throw new Error("invert: expected positive modulus, got "+n);let t=Y(e,n),o=n,i=V,a=_,f=_,d=V;for(;t!==V;){const r=o/t,u=o%t,g=i-f*r,L=a-d*r;o=t,t=u,i=f,a=d,f=g,d=L}if(o!==_)throw new Error("invert: does not exist");return Y(i,n)}function $t(e,n){const t=(e.ORDER+_)/Ut,o=e.pow(n,t);if(!e.eql(e.sqr(o),n))throw new Error("Cannot find square root");return o}function he(e,n){const t=(e.ORDER-Kt)/Pt,o=e.mul(n,tt),i=e.pow(o,t),a=e.mul(n,i),f=e.mul(e.mul(a,tt),i),d=e.mul(a,e.sub(f,e.ONE));if(!e.eql(e.sqr(d),n))throw new Error("Cannot find square root");return d}function we(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-_,t=0;for(;n%tt===V;)n/=tt,t++;let o=tt;const i=Nt(e);for(;Rt(i,o)===1;)if(o++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return $t;let a=i.pow(o,n);const f=(n+_)/tt;return function(r,u){if(r.is0(u))return u;if(Rt(r,u)!==1)throw new Error("Cannot find square root");let g=t,L=r.mul(r.ONE,a),O=r.pow(u,n),z=r.pow(u,f);for(;!r.eql(O,r.ONE);){if(r.is0(O))return r.ZERO;let Z=1,m=r.sqr(O);for(;!r.eql(m,r.ONE);)if(Z++,m=r.sqr(m),Z===g)throw new Error("Cannot find square root");const C=_<<BigInt(g-Z-1),H=r.pow(L,C);g=Z,L=r.sqr(H),O=r.mul(O,L),z=r.mul(z,H)}return z}}function ge(e){return e%Ut===de?$t:e%Pt===Kt?he:we(e)}var me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pe(e){const n=me.reduce((t,o)=>(t[o]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return ut(e,n)}function ye(e,n,t){if(t<V)throw new Error("invalid exponent, negatives unsupported");if(t===V)return e.ONE;if(t===_)return n;let o=e.ONE,i=n;for(;t>V;)t&_&&(o=e.mul(o,i)),i=e.sqr(i),t>>=_;return o}function Gt(e,n,t=!1){const o=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((f,d,r)=>e.is0(d)?f:(o[r]=f,e.mul(f,d)),e.ONE),a=e.inv(i);return n.reduceRight((f,d,r)=>e.is0(d)?f:(o[r]=e.mul(f,o[r]),e.mul(f,d)),a),o}function Rt(e,n){const t=(e.ORDER-_)/tt,o=e.pow(n,t),i=e.eql(o,e.ONE),a=e.eql(o,e.ZERO),f=e.eql(o,e.neg(e.ONE));if(!i&&!a&&!f)throw new Error("invalid Legendre symbol result");return i?1:a?0:-1}function Wt(e,n){n!==void 0&&ie(n);const t=n!==void 0?n:e.toString(2).length,o=Math.ceil(t/8);return{nBitLength:t,nByteLength:o}}function Nt(e,n,t=!1,o={}){if(e<=V)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:i,nByteLength:a}=Wt(e,n);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const d=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:a,MASK:lt(i),ZERO:V,ONE:_,create:r=>Y(r,e),isValid:r=>{if(typeof r!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof r);return V<=r&&r<e},is0:r=>r===V,isOdd:r=>(r&_)===_,neg:r=>Y(-r,e),eql:(r,u)=>r===u,sqr:r=>Y(r*r,e),add:(r,u)=>Y(r+u,e),sub:(r,u)=>Y(r-u,e),mul:(r,u)=>Y(r*u,e),pow:(r,u)=>ye(d,r,u),div:(r,u)=>Y(r*Bt(u,e),e),sqrN:r=>r*r,addN:(r,u)=>r+u,subN:(r,u)=>r-u,mulN:(r,u)=>r*u,inv:r=>Bt(r,e),sqrt:o.sqrt||(r=>(f||(f=ge(e)),f(d,r))),toBytes:r=>t?Ct(r,a):ft(r,a),fromBytes:r=>{if(r.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+r.length);return t?Vt(r):et(r)},invertBatch:r=>Gt(d,r),cmov:(r,u,g)=>g?u:r});return Object.freeze(d)}function Dt(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Xt(e){const n=Dt(e);return n+Math.ceil(n/2)}function Ee(e,n,t=!1){const o=e.length,i=Dt(n),a=Xt(n);if(o<16||o<a||o>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+o);const f=t?Vt(e):et(e),d=Y(f,n-_)+_;return t?Ct(d,i):ft(d,i)}var Ht=BigInt(0),xt=BigInt(1);function wt(e,n){const t=n.negate();return e?t:n}function Qt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function gt(e,n){Qt(e,n);const t=Math.ceil(n/e)+1,o=2**(e-1),i=2**e,a=lt(e),f=BigInt(e);return{windows:t,windowSize:o,mask:a,maxNumber:i,shiftBy:f}}function Zt(e,n,t){const{windowSize:o,mask:i,maxNumber:a,shiftBy:f}=t;let d=Number(e&i),r=e>>f;d>o&&(d-=a,r+=xt);const u=n*o,g=u+Math.abs(d)-1,L=d===0,O=d<0,z=n%2!==0;return{nextN:r,offset:g,isZero:L,isNeg:O,isNegF:z,offsetF:u}}function be(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,o)=>{if(!(t instanceof n))throw new Error("invalid point at index "+o)})}function ve(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,o)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+o)})}var mt=new WeakMap,Jt=new WeakMap;function pt(e){return Jt.get(e)||1}function Be(e,n){return{constTimeNegate:wt,hasPrecomputes(t){return pt(t)!==1},unsafeLadder(t,o,i=e.ZERO){let a=t;for(;o>Ht;)o&xt&&(i=i.add(a)),a=a.double(),o>>=xt;return i},precomputeWindow(t,o){const{windows:i,windowSize:a}=gt(o,n),f=[];let d=t,r=d;for(let u=0;u<i;u++){r=d,f.push(r);for(let g=1;g<a;g++)r=r.add(d),f.push(r);d=r.double()}return f},wNAF(t,o,i){let a=e.ZERO,f=e.BASE;const d=gt(t,n);for(let r=0;r<d.windows;r++){const{nextN:u,offset:g,isZero:L,isNeg:O,isNegF:z,offsetF:Z}=Zt(i,r,d);i=u,L?f=f.add(wt(z,o[Z])):a=a.add(wt(O,o[g]))}return{p:a,f}},wNAFUnsafe(t,o,i,a=e.ZERO){const f=gt(t,n);for(let d=0;d<f.windows&&i!==Ht;d++){const{nextN:r,offset:u,isZero:g,isNeg:L}=Zt(i,d,f);if(i=r,!g){const O=o[u];a=a.add(L?O.negate():O)}}return a},getPrecomputes(t,o,i){let a=mt.get(o);return a||(a=this.precomputeWindow(o,t),t!==1&&mt.set(o,i(a))),a},wNAFCached(t,o,i){const a=pt(t);return this.wNAF(a,this.getPrecomputes(a,t,i),o)},wNAFCachedUnsafe(t,o,i,a){const f=pt(t);return f===1?this.unsafeLadder(t,o,a):this.wNAFUnsafe(f,this.getPrecomputes(f,t,i),o,a)},setWindowSize(t,o){Qt(o,n),Jt.set(t,o),mt.delete(t)}}}function xe(e,n,t,o){be(t,e),ve(o,n);const i=t.length,a=o.length;if(i!==a)throw new Error("arrays of points and scalars must have equal length");const f=e.ZERO,d=ne(BigInt(i));let r=1;d>12?r=d-3:d>4?r=d-2:d>0&&(r=2);const u=lt(r),g=new Array(Number(u)+1).fill(f),L=Math.floor((n.BITS-1)/r)*r;let O=f;for(let z=L;z>=0;z-=r){g.fill(f);for(let m=0;m<a;m++){const C=o[m],H=Number(C>>BigInt(z)&u);g[H]=g[H].add(t[m])}let Z=f;for(let m=g.length-1,C=f;m>0;m--)C=C.add(g[m]),Z=Z.add(C);if(O=O.add(Z),z!==0)for(let m=0;m<r;m++)O=O.double()}return O}function Ft(e){return pe(e.Fp),ut(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Wt(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function zt(e){e.lowS!==void 0&&at("lowS",e.lowS),e.prehash!==void 0&&at("prehash",e.prehash)}function Se(e){const n=Ft(e);ut(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:o,a:i}=n;if(t){if(!o.eql(i,o.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var Ie=class extends Error{constructor(e=""){super(e)}};const W={Err:Ie,_tlv:{encode:(e,n)=>{const{Err:t}=W;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const o=n.length/2,i=ct(o);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const a=o>127?ct(i.length/2|128):"";return ct(e)+a+i+n},decode(e,n){const{Err:t}=W;let o=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[o++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[o++],a=!!(i&128);let f=0;if(!a)f=i;else{const r=i&127;if(!r)throw new t("tlv.decode(long): indefinite length not supported");if(r>4)throw new t("tlv.decode(long): byte length is too big");const u=n.subarray(o,o+r);if(u.length!==r)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const g of u)f=f<<8|g;if(o+=r,f<128)throw new t("tlv.decode(long): not minimal encoding")}const d=n.subarray(o,o+f);if(d.length!==f)throw new t("tlv.decode: wrong value length");return{v:d,l:n.subarray(o+f)}}},_int:{encode(e){const{Err:n}=W;if(e<D)throw new n("integer: negative integers are not allowed");let t=ct(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=W;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return et(e)}},toSig(e){const{Err:n,_int:t,_tlv:o}=W,i=K("signature",e),{v:a,l:f}=o.decode(48,i);if(f.length)throw new n("invalid signature: left bytes after parsing");const{v:d,l:r}=o.decode(2,a),{v:u,l:g}=o.decode(2,r);if(g.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(d),s:t.decode(u)}},hexFromSig(e){const{_tlv:n,_int:t}=W,o=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),a=o+i;return n.encode(48,a)}};function yt(e,n){return bt(ft(e,n))}var D=BigInt(0),T=BigInt(1),Ce=BigInt(2),Et=BigInt(3),Ne=BigInt(4);function qe(e){const n=Se(e),{Fp:t}=n,o=Nt(n.n,n.nBitLength),i=n.toBytes||((B,s,h)=>{const p=s.toAffine();return vt(Uint8Array.from([4]),t.toBytes(p.x),t.toBytes(p.y))}),a=n.fromBytes||(B=>{const s=B.subarray(1),h=t.fromBytes(s.subarray(0,t.BYTES)),p=t.fromBytes(s.subarray(t.BYTES,2*t.BYTES));return{x:h,y:p}});function f(B){const{a:s,b:h}=n,p=t.sqr(B),v=t.mul(p,B);return t.add(t.add(v,t.mul(B,s)),h)}function d(B,s){const h=t.sqr(s),p=f(B);return t.eql(h,p)}if(!d(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const r=t.mul(t.pow(n.a,Et),Ne),u=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(r,u)))throw new Error("bad curve params: a or b");function g(B){return _t(B,T,n.n)}function L(B){const{allowedPrivateKeyLengths:s,nByteLength:h,wrapPrivateKey:p,n:v}=n;if(s&&typeof B!="bigint"){if(Mt(B)&&(B=bt(B)),typeof B!="string"||!s.includes(B.length))throw new Error("invalid private key");B=B.padStart(h*2,"0")}let N;try{N=typeof B=="bigint"?B:et(K("private key",B,h))}catch(A){throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof B)}return p&&(N=Y(N,v)),it("private key",N,T,v),N}function O(B){if(!(B instanceof m))throw new Error("ProjectivePoint expected")}const z=At((B,s)=>{const{px:h,py:p,pz:v}=B;if(t.eql(v,t.ONE))return{x:h,y:p};const N=B.is0();s==null&&(s=N?t.ONE:t.inv(v));const A=t.mul(h,s),q=t.mul(p,s),y=t.mul(v,s);if(N)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:A,y:q}}),Z=At(B=>{if(B.is0()){if(n.allowInfinityPoint&&!t.is0(B.py))return;throw new Error("bad point: ZERO")}const{x:s,y:h}=B.toAffine();if(!t.isValid(s)||!t.isValid(h))throw new Error("bad point: x or y not FE");if(!d(s,h))throw new Error("bad point: equation left != right");if(!B.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class m{constructor(s,h,p){if(s==null||!t.isValid(s))throw new Error("x required");if(h==null||!t.isValid(h)||t.is0(h))throw new Error("y required");if(p==null||!t.isValid(p))throw new Error("z required");this.px=s,this.py=h,this.pz=p,Object.freeze(this)}static fromAffine(s){const{x:h,y:p}=s||{};if(!s||!t.isValid(h)||!t.isValid(p))throw new Error("invalid affine point");if(s instanceof m)throw new Error("projective point not allowed");const v=N=>t.eql(N,t.ZERO);return v(h)&&v(p)?m.ZERO:new m(h,p,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(s){const h=Gt(t,s.map(p=>p.pz));return s.map((p,v)=>p.toAffine(h[v])).map(m.fromAffine)}static fromHex(s){const h=m.fromAffine(a(K("pointHex",s)));return h.assertValidity(),h}static fromPrivateKey(s){return m.BASE.multiply(L(s))}static msm(s,h){return xe(m,o,s,h)}_setWindowSize(s){$.setWindowSize(this,s)}assertValidity(){Z(this)}hasEvenY(){const{y:s}=this.toAffine();if(t.isOdd)return!t.isOdd(s);throw new Error("Field doesn't support isOdd")}equals(s){O(s);const{px:h,py:p,pz:v}=this,{px:N,py:A,pz:q}=s,y=t.eql(t.mul(h,q),t.mul(N,v)),I=t.eql(t.mul(p,q),t.mul(A,v));return y&&I}negate(){return new m(this.px,t.neg(this.py),this.pz)}double(){const{a:s,b:h}=n,p=t.mul(h,Et),{px:v,py:N,pz:A}=this;let q=t.ZERO,y=t.ZERO,I=t.ZERO,E=t.mul(v,v),k=t.mul(N,N),l=t.mul(A,A),c=t.mul(v,N);return c=t.add(c,c),I=t.mul(v,A),I=t.add(I,I),q=t.mul(s,I),y=t.mul(p,l),y=t.add(q,y),q=t.sub(k,y),y=t.add(k,y),y=t.mul(q,y),q=t.mul(c,q),I=t.mul(p,I),l=t.mul(s,l),c=t.sub(E,l),c=t.mul(s,c),c=t.add(c,I),I=t.add(E,E),E=t.add(I,E),E=t.add(E,l),E=t.mul(E,c),y=t.add(y,E),l=t.mul(N,A),l=t.add(l,l),E=t.mul(l,c),q=t.sub(q,E),I=t.mul(l,k),I=t.add(I,I),I=t.add(I,I),new m(q,y,I)}add(s){O(s);const{px:h,py:p,pz:v}=this,{px:N,py:A,pz:q}=s;let y=t.ZERO,I=t.ZERO,E=t.ZERO;const k=n.a,l=t.mul(n.b,Et);let c=t.mul(h,N),w=t.mul(p,A),x=t.mul(v,q),b=t.add(h,p),S=t.add(N,A);b=t.mul(b,S),S=t.add(c,w),b=t.sub(b,S),S=t.add(h,v);let R=t.add(N,q);return S=t.mul(S,R),R=t.add(c,x),S=t.sub(S,R),R=t.add(p,v),y=t.add(A,q),R=t.mul(R,y),y=t.add(w,x),R=t.sub(R,y),E=t.mul(k,S),y=t.mul(l,x),E=t.add(y,E),y=t.sub(w,E),E=t.add(w,E),I=t.mul(y,E),w=t.add(c,c),w=t.add(w,c),x=t.mul(k,x),S=t.mul(l,S),w=t.add(w,x),x=t.sub(c,x),x=t.mul(k,x),S=t.add(S,x),c=t.mul(w,S),I=t.add(I,c),c=t.mul(R,S),y=t.mul(b,y),y=t.sub(y,c),c=t.mul(b,w),E=t.mul(R,E),E=t.add(E,c),new m(y,I,E)}subtract(s){return this.add(s.negate())}is0(){return this.equals(m.ZERO)}wNAF(s){return $.wNAFCached(this,s,m.normalizeZ)}multiplyUnsafe(s){const{endo:h,n:p}=n;it("scalar",s,D,p);const v=m.ZERO;if(s===D)return v;if(this.is0()||s===T)return this;if(!h||$.hasPrecomputes(this))return $.wNAFCachedUnsafe(this,s,m.normalizeZ);let{k1neg:N,k1:A,k2neg:q,k2:y}=h.splitScalar(s),I=v,E=v,k=this;for(;A>D||y>D;)A&T&&(I=I.add(k)),y&T&&(E=E.add(k)),k=k.double(),A>>=T,y>>=T;return N&&(I=I.negate()),q&&(E=E.negate()),E=new m(t.mul(E.px,h.beta),E.py,E.pz),I.add(E)}multiply(s){const{endo:h,n:p}=n;it("scalar",s,T,p);let v,N;if(h){const{k1neg:A,k1:q,k2neg:y,k2:I}=h.splitScalar(s);let{p:E,f:k}=this.wNAF(q),{p:l,f:c}=this.wNAF(I);E=$.constTimeNegate(A,E),l=$.constTimeNegate(y,l),l=new m(t.mul(l.px,h.beta),l.py,l.pz),v=E.add(l),N=k.add(c)}else{const{p:A,f:q}=this.wNAF(s);v=A,N=q}return m.normalizeZ([v,N])[0]}multiplyAndAddUnsafe(s,h,p){const v=m.BASE,N=(q,y)=>y===D||y===T||!q.equals(v)?q.multiplyUnsafe(y):q.multiply(y),A=N(this,h).add(N(s,p));return A.is0()?void 0:A}toAffine(s){return z(this,s)}isTorsionFree(){const{h:s,isTorsionFree:h}=n;if(s===T)return!0;if(h)return h(m,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:s,clearCofactor:h}=n;return s===T?this:h?h(m,this):this.multiplyUnsafe(n.h)}toRawBytes(s=!0){return at("isCompressed",s),this.assertValidity(),i(m,this,s)}toHex(s=!0){return at("isCompressed",s),bt(this.toRawBytes(s))}}m.BASE=new m(n.Gx,n.Gy,t.ONE),m.ZERO=new m(t.ZERO,t.ONE,t.ZERO);const{endo:C,nBitLength:H}=n,$=Be(m,C?Math.ceil(H/2):H);return{CURVE:n,ProjectivePoint:m,normPrivateKeyToScalar:L,weierstrassEquation:f,isWithinCurveOrder:g}}function Oe(e){const n=Ft(e);return ut(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ae(e){const n=Oe(e),{Fp:t,n:o,nByteLength:i,nBitLength:a}=n,f=t.BYTES+1,d=2*t.BYTES+1;function r(l){return Y(l,o)}function u(l){return Bt(l,o)}const{ProjectivePoint:g,normPrivateKeyToScalar:L,weierstrassEquation:O,isWithinCurveOrder:z}=qe({...n,toBytes(l,c,w){const x=c.toAffine(),b=t.toBytes(x.x),S=vt;return at("isCompressed",w),w?S(Uint8Array.from([c.hasEvenY()?2:3]),b):S(Uint8Array.from([4]),b,t.toBytes(x.y))},fromBytes(l){const c=l.length,w=l[0],x=l.subarray(1);if(c===f&&(w===2||w===3)){const b=et(x);if(!_t(b,T,t.ORDER))throw new Error("Point is not on curve");const S=O(b);let R;try{R=t.sqrt(S)}catch(P){const G=P instanceof Error?": "+P.message:"";throw new Error("Point is not on curve"+G)}const M=(R&T)===T;return(w&1)===1!==M&&(R=t.neg(R)),{x:b,y:R}}else if(c===d&&w===4){const b=t.fromBytes(x.subarray(0,t.BYTES)),S=t.fromBytes(x.subarray(t.BYTES,2*t.BYTES));return{x:b,y:S}}else{const b=f,S=d;throw new Error("invalid Point, expected length of "+b+", or uncompressed "+S+", got "+c)}}});function Z(l){const c=o>>T;return l>c}function m(l){return Z(l)?r(-l):l}const C=(l,c,w)=>et(l.slice(c,w));class H{constructor(c,w,x){it("r",c,T,o),it("s",w,T,o),this.r=c,this.s=w,x!=null&&(this.recovery=x),Object.freeze(this)}static fromCompact(c){const w=i;return c=K("compactSignature",c,w*2),new H(C(c,0,w),C(c,w,2*w))}static fromDER(c){const{r:w,s:x}=W.toSig(K("DER",c));return new H(w,x)}assertValidity(){}addRecoveryBit(c){return new H(this.r,this.s,c)}recoverPublicKey(c){const{r:w,s:x,recovery:b}=this,S=v(K("msgHash",c));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");const R=b===2||b===3?w+n.n:w;if(R>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const M=(b&1)===0?"02":"03",P=g.fromHex(M+yt(R,t.BYTES)),G=u(R),j=r(-S*G),nt=r(x*G),X=g.BASE.multiplyAndAddUnsafe(P,j,nt);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return Z(this.s)}normalizeS(){return this.hasHighS()?new H(this.r,r(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return W.hexFromSig(this)}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){const c=i;return yt(this.r,c)+yt(this.s,c)}}const $={isValidPrivateKey(l){try{return L(l),!0}catch(c){return!1}},normPrivateKeyToScalar:L,randomPrivateKey:()=>{const l=Xt(n.n);return Ee(n.randomBytes(l),n.n)},precompute(l=8,c=g.BASE){return c._setWindowSize(l),c.multiply(BigInt(3)),c}};function B(l,c=!0){return g.fromPrivateKey(l).toRawBytes(c)}function s(l){if(typeof l=="bigint")return!1;if(l instanceof g)return!0;const c=K("key",l).length,w=t.BYTES,x=w+1,b=2*w+1;if(!(n.allowedPrivateKeyLengths||i===x))return c===x||c===b}function h(l,c,w=!0){if(s(l)===!0)throw new Error("first arg must be private key");if(s(c)===!1)throw new Error("second arg must be public key");return g.fromHex(c).multiply(L(l)).toRawBytes(w)}const p=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const c=et(l),w=l.length*8-a;return w>0?c>>BigInt(w):c},v=n.bits2int_modN||function(l){return r(p(l))},N=lt(a);function A(l){return it("num < 2^"+a,l,D,N),ft(l,i)}function q(l,c,w=y){if(["recovered","canonical"].some(Q=>Q in w))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:b}=n;let{lowS:S,prehash:R,extraEntropy:M}=w;S==null&&(S=!0),l=K("msgHash",l),zt(w),R&&(l=K("prehashed msgHash",x(l)));const P=v(l),G=L(c),j=[A(G),A(P)];if(M!=null&&M!==!1){const Q=M===!0?b(t.BYTES):M;j.push(K("extraEntropy",Q))}const nt=vt(...j),X=P;function dt(Q){const rt=p(Q);if(!z(rt))return;const ht=u(rt),st=g.BASE.multiply(rt).toAffine(),J=r(st.x);if(J===D)return;const F=r(ht*r(X+J*G));if(F===D)return;let ot=(st.x===J?0:2)|Number(st.y&T),qt=F;return S&&Z(F)&&(qt=m(F),ot^=1),new H(J,qt,ot)}return{seed:nt,k2sig:dt}}const y={lowS:n.lowS,prehash:!1},I={lowS:n.lowS,prehash:!1};function E(l,c,w=y){const{seed:x,k2sig:b}=q(l,c,w),S=n;return ee(S.hash.outputLen,S.nByteLength,S.hmac)(x,b)}g.BASE._setWindowSize(8);function k(l,c,w,x=I){var F;const b=l;c=K("msgHash",c),w=K("publicKey",w);const{lowS:S,prehash:R,format:M}=x;if(zt(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(M!==void 0&&M!=="compact"&&M!=="der")throw new Error("format must be compact or der");const P=typeof b=="string"||Mt(b),G=!P&&!M&&typeof b=="object"&&b!==null&&typeof b.r=="bigint"&&typeof b.s=="bigint";if(!P&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,nt;try{if(G&&(j=new H(b.r,b.s)),P){try{M!=="compact"&&(j=H.fromDER(b))}catch(ot){if(!(ot instanceof W.Err))throw ot}!j&&M!=="der"&&(j=H.fromCompact(b))}nt=g.fromHex(w)}catch(ot){return!1}if(!j||S&&j.hasHighS())return!1;R&&(c=n.hash(c));const{r:X,s:dt}=j,Q=v(c),rt=u(dt),ht=r(Q*rt),st=r(X*rt),J=(F=g.BASE.multiplyAndAddUnsafe(nt,ht,st))==null?void 0:F.toAffine();return J?r(J.x)===X:!1}return{CURVE:n,getPublicKey:B,getSharedSecret:h,sign:E,verify:k,ProjectivePoint:g,Signature:H,utils:$}}function Le(e){return{hash:e,hmac:(n,...t)=>jt(e,n,ce(...t)),randomBytes:fe}}function Re(e,n){const t=o=>Ae({...e,...Le(o)});return{...t(n),create:t}}var te=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Tt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),He=BigInt(0),Ze=BigInt(1),St=BigInt(2),kt=(e,n)=>(e+n/St)/n;function ze(e){const n=te,t=BigInt(3),o=BigInt(6),i=BigInt(11),a=BigInt(22),f=BigInt(23),d=BigInt(44),r=BigInt(88),u=e*e*e%n,g=u*u*e%n,L=U(g,t,n)*g%n,O=U(L,t,n)*g%n,z=U(O,St,n)*u%n,Z=U(z,i,n)*z%n,m=U(Z,a,n)*Z%n,C=U(m,d,n)*m%n,H=U(C,r,n)*C%n,$=U(H,d,n)*m%n,B=U($,t,n)*g%n,s=U(B,f,n)*Z%n,h=U(s,o,n)*u%n,p=U(h,St,n);if(!It.eql(It.sqr(p),e))throw new Error("Cannot find square root");return p}var It=Nt(te,void 0,void 0,{sqrt:ze});const Me=Re({a:He,b:BigInt(7),Fp:It,n:Tt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=Tt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),o=-Ze*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),a=t,f=BigInt("0x100000000000000000000000000000000"),d=kt(a*e,n),r=kt(-o*e,n);let u=Y(e-d*t-r*i,n),g=Y(-d*o-r*a,n);const L=u>f,O=g>f;if(L&&(u=n-u),O&&(g=n-g),u>f||g>f)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:L,k1:u,k2neg:O,k2:g}}}},re);export{Me as secp256k1};
