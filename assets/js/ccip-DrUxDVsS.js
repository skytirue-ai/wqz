import{$ as t,A as e,C as a,D as s,E as r,F as n,I as o,L as c,M as i,R as u,T as d,dt as l,et as f,it as h,j as p,k as w,lt as m,nt as y,ot as g,r as b,rt as k,st as x,tt as R,ut as M,w as E}from"./index-8QL3Kgp0.js";var L="/docs/contract/encodeErrorResult";function O(t){const{abi:a,errorName:s,args:r}=t;let n=a[0];if(s){const t=w({abi:a,args:r,name:s});if(!t)throw new R(s,{docsPath:L});n=t}if("error"!==n.type)throw new R(void 0,{docsPath:L});const c=M(n),u=e(c);let d="0x";if(r&&r.length>0){if(!n.inputs)throw new f(n.name,{docsPath:L});d=i(n.inputs,r)}return o([u,d])}var P="/docs/contract/encodeFunctionResult";async function v(t){const{data:a,ccipRequest:r}=t,{args:[n]}=function(t){const{abi:a,data:s}=t,r=c(s,0,4),n=a.find(t=>"function"===t.type&&r===e(M(t)));if(!n)throw new h(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:n.name,args:"inputs"in n&&n.inputs&&n.inputs.length>0?p(n.inputs,c(s,4)):void 0}}({abi:l,data:a}),o=[],u=[];return await Promise.all(n.map(async(t,e)=>{try{u[e]=t.urls.includes("x-batch-gateway:true")?await v({data:t.data,ccipRequest:r}):await r(t),o[e]=!1}catch(n){o[e]=!0,u[e]="HttpRequestError"===(a=n).name&&a.status?O({abi:l,errorName:"HttpError",args:[a.status,a.shortMessage]}):O({abi:[s],errorName:"Error",args:["shortMessage"in a?a.shortMessage:a.message]})}var a})),function(t){const{abi:e,functionName:a,result:s}=t;let r=e[0];if(a){const t=w({abi:e,name:a});if(!t)throw new y(a,{docsPath:P});r=t}if("function"!==r.type)throw new y(void 0,{docsPath:P});if(!r.outputs)throw new k(r.name,{docsPath:P});const n=(()=>{if(0===r.outputs.length)return[];if(1===r.outputs.length)return[s];if(Array.isArray(s))return s;throw new g(s)})();return i(r.outputs,n)}({abi:l,functionName:"query",result:[o,u]})}var T=class extends x{constructor({callbackSelector:t,cause:e,data:a,extraData:s,sender:r,urls:n}){super(e.shortMessage||"An error occurred while fetching for an offchain result.",{cause:e,metaMessages:[...e.metaMessages||[],e.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(t=>`    ${E(t)}`)],`  Sender: ${r}`,`  Data: ${a}`,`  Callback selector: ${t}`,`  Extra data: ${s}`].flat(),name:"OffchainLookupError"})}},$=class extends x{constructor({result:t,url:e}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${E(e)}`,`Response: ${d(t)}`],name:"OffchainLookupResponseMalformedError"})}},C=class extends x{constructor({sender:t,to:e}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${e}`,`OffchainLookup sender address: ${t}`],name:"OffchainLookupSenderMismatchError"})}};const N="0x556f1830",S={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function q(e,{blockNumber:a,blockTag:s,data:o,to:c}){const{args:d}=r({data:o,abi:[S]}),[l,f,h,p,w]=d,{ccipRead:m}=e,y=m&&"function"==typeof m?.request?m.request:D;try{if(!function(e,a){if(!u(e,{strict:!1}))throw new t({address:e});if(!u(a,{strict:!1}))throw new t({address:a});return e.toLowerCase()===a.toLowerCase()}(c,l))throw new C({sender:l,to:c});const r=f.includes("x-batch-gateway:true")?await v({data:h,ccipRequest:y}):await y({data:h,sender:l,urls:f}),{data:o}=await b(e,{blockNumber:a,blockTag:s,data:n([p,i([{type:"bytes"},{type:"bytes"}],[r,w])]),to:c});return o}catch(g){throw new T({callbackSelector:p,cause:g,data:o,extraData:w,sender:l,urls:f})}}async function D({data:t,sender:e,urls:s}){let r=new Error("An unknown error occurred.");for(let o=0;o<s.length;o++){const c=s[o],i=c.includes("{data}")?"GET":"POST",u="POST"===i?{data:t,sender:e}:void 0,l="POST"===i?{"Content-Type":"application/json"}:{};try{const s=await fetch(c.replace("{sender}",e.toLowerCase()).replace("{data}",t),{body:JSON.stringify(u),headers:l,method:i});let n;if(n=s.headers.get("Content-Type")?.startsWith("application/json")?(await s.json()).data:await s.text(),!s.ok){r=new a({body:u,details:n?.error?d(n.error):s.statusText,headers:s.headers,status:s.status,url:c});continue}if(!m(n)){r=new $({result:n,url:c});continue}return n}catch(n){r=new a({body:u,details:n.message,url:c})}}throw r}export{D as ccipRequest,q as offchainLookup,S as offchainLookupAbiItem,N as offchainLookupSignature};