import{C,T as m,t as S,v as $,y as T}from"./call-CqBnerh1.js";import{C as b,O as I,T as D,b as G,c as w,f as H,k as O,m as E,n as v,p as U,r as F,w as j,x as A}from"./encodeFunctionData-C6-0T83L.js";import"./utils-DgRhDAqe.js";import{A as R,Ct as B,L as M,N,V as x,bt as k,xt as y}from"./index-CoOnDRry.js";function _(e){const{abi:a,data:o}=e,r=E(o,0,4),t=a.find(n=>n.type==="function"&&r===F(O(n)));if(!t)throw new D(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?C(t.inputs,E(o,4)):void 0}}var p="/docs/contract/encodeErrorResult";function L(e){const{abi:a,errorName:o,args:r}=e;let t=a[0];if(o){const d=v({abi:a,args:r,name:o});if(!d)throw new A(o,{docsPath:p});t=d}if(t.type!=="error")throw new A(void 0,{docsPath:p});const n=O(t),s=F(n);let c="0x";if(r&&r.length>0){if(!t.inputs)throw new G(t.name,{docsPath:p});c=w(t.inputs,r)}return U([s,c])}var h="/docs/contract/encodeFunctionResult";function J(e){const{abi:a,functionName:o,result:r}=e;let t=a[0];if(o){const s=v({abi:a,name:o});if(!s)throw new b(o,{docsPath:h});t=s}if(t.type!=="function")throw new b(void 0,{docsPath:h});if(!t.outputs)throw new j(t.name,{docsPath:h});const n=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new I(r)})();return w(t.outputs,n)}async function q(e){const{data:a,ccipRequest:o}=e,{args:[r]}=_({abi:m,data:a}),t=[],n=[];return await Promise.all(r.map(async(s,c)=>{try{n[c]=s.urls.includes("x-batch-gateway:true")?await q({data:s.data,ccipRequest:o}):await o(s),t[c]=!1}catch(d){t[c]=!0,n[c]=V(d)}})),J({abi:m,functionName:"query",result:[t,n]})}function V(e){return e.name==="HttpRequestError"&&e.status?L({abi:m,errorName:"HttpError",args:[e.status,e.shortMessage]}):L({abi:[T],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}function W(e,a){if(!x(e,{strict:!1}))throw new k({address:e});if(!x(a,{strict:!1}))throw new k({address:a});return e.toLowerCase()===a.toLowerCase()}var z=class extends y{constructor({callbackSelector:e,cause:a,data:o,extraData:r,sender:t,urls:n}){var s;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],(s=a.metaMessages)!=null&&s.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(c=>"    ".concat(N(c)))],"  Sender: ".concat(t),"  Data: ".concat(o),"  Callback selector: ".concat(e),"  Extra data: ".concat(r)].flat(),name:"OffchainLookupError"})}},K=class extends y{constructor({result:e,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:["Gateway URL: ".concat(N(a)),"Response: ".concat(M(e))],name:"OffchainLookupResponseMalformedError"})}},Q=class extends y{constructor({sender:e,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:["Contract address: ".concat(a),"OffchainLookup sender address: ".concat(e)],name:"OffchainLookupSenderMismatchError"})}};const rt="0x556f1830",X={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function st(e,{blockNumber:a,blockTag:o,data:r,to:t}){const{args:n}=$({data:r,abi:[X]}),[s,c,d,f,u]=n,{ccipRead:i}=e,g=i&&typeof(i==null?void 0:i.request)=="function"?i.request:Y;try{if(!W(t,s))throw new Q({sender:s,to:t});const l=c.includes("x-batch-gateway:true")?await q({data:d,ccipRequest:g}):await g({data:d,sender:s,urls:c}),{data:P}=await S(e,{blockNumber:a,blockTag:o,data:H([f,w([{type:"bytes"},{type:"bytes"}],[l,u])]),to:t});return P}catch(l){throw new z({callbackSelector:f,cause:l,data:r,extraData:u,sender:s,urls:c})}}async function Y({data:e,sender:a,urls:o}){var t;let r=new Error("An unknown error occurred.");for(let n=0;n<o.length;n++){const s=o[n],c=s.includes("{data}")?"GET":"POST",d=c==="POST"?{data:e,sender:a}:void 0,f=c==="POST"?{"Content-Type":"application/json"}:{};try{const u=await fetch(s.replace("{sender}",a.toLowerCase()).replace("{data}",e),{body:JSON.stringify(d),headers:f,method:c});let i;if((t=u.headers.get("Content-Type"))!=null&&t.startsWith("application/json")?i=(await u.json()).data:i=await u.text(),!u.ok){r=new R({body:d,details:i!=null&&i.error?M(i.error):u.statusText,headers:u.headers,status:u.status,url:s});continue}if(!B(i)){r=new K({result:i,url:s});continue}return i}catch(u){r=new R({body:d,details:u.message,url:s})}}throw r}export{Y as ccipRequest,st as offchainLookup,X as offchainLookupAbiItem,rt as offchainLookupSignature};
